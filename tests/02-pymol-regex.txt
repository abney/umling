
#--  Lecture: Pymol (cont'd)  --------------------------------------------------

#--  Regular expressions

# 10. Basic regular expressions
>>> from umling.pymol import *
>>> at.a
/a/
>>> at.epsilon
/ε/
>>> at.emptyset
/∅/
>>> (at.a + at.b) * at.c
/(a + b)⋅c/
>>> star(at.a)
/a*/

# 12. Coercion to language
>>> lg('a')
/a/
>>> lg(letters('abc'))
/a⋅b⋅c/
>>> lg(alphabet('abc'))
/a + b + c/
>>> alphabet('bdg') * letters('at')
/(b + d + g)⋅(a⋅t)/
>>> alphabet('bdg') * 'a'
/(b + d + g)⋅a/
>>> alphabet('bdg') * alphabet('ai')
/(b + d + g)⋅(a + i)/
>>> star('a')
/a*/
>>> letters('cat') + letters('dog')
/(c⋅a⋅t) + (d⋅o⋅g)/

# 13. Enumeration
>>> enum(alphabet('bdg') * alphabet('ai'))
[0] <'b', 'a'>
[1] <'b', 'i'>
[2] <'d', 'a'>
[3] <'d', 'i'>
[4] <'g', 'a'>
[5] <'g', 'i'>
>>> enum(lg(epsilon))
[0] ε
>>> enum(lg(emptyset))
(empty)
>>> A = letters('cat') + letters('dog')

# 14. Algebra
>>> enum(A)
>>> enum(A * set(epsilon))
>>> type(A)
>>> type(A * set(epsilon))
>>> A * set(epsilon) == A
True
>>> enum(A * emptyset)
(empty)
>>> U = at.a + at.b
>>> L = U * at.c
>>> L
/(a + b)⋅c/


# Extra
>>> enum(alphabet('ab') * at.epsilon)
[0] <'a'>
[1] <'b'>
>>> enum(alphabet('ab') * at.emptyset)
(empty)


>>> star('a')
/a*/

>>> N = at.dog + at.cat
>>> V = at.saw + at.chased
>>> NP = at.the * RC
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/doctest.py", line 1368, in __run
    exec(compile(example.source, filename, "single",
  File "<doctest pymol-regex-tests.txt[17]>", line 1, in <module>
    NP = at.the * RC
                  ^^
NameError: name 'RC' is not defined

# Additional comments
>>> (lg('a') + 'b') * 'c'
/(a + b)⋅c/
>>> set('a', 'b') * 'c'
/(a + b)⋅c/
>>> U = lg('a') + lg('b')
>>> L = U * lg('c')
>>> L
/(a + b)⋅c/
>>> seq('a', 'c') in L
True
>>> enum(L)
[0] <'a', 'c'>
[1] <'b', 'c'>

>>> X = set(seq('p'), seq('t')) * set(seq('a'), seq('i'))
>>> X
/(p + t)⋅(a + i)/
>>> enum(X)
[0] <'p', 'a'>
[1] <'p', 'i'>
[2] <'t', 'a'>
[3] <'t', 'i'>
>>> A = set(letters('cat'), letters('dog'))
>>> B = set(letters('s'), epsilon)
>>> enum(A * B)
[0] <'c', 'a', 't'>
[1] <'d', 'o', 'g'>
[2] <'c', 'a', 't', 's'>
[3] <'d', 'o', 'g', 's'>
>>> enum(A * set(epsilon))
[0] <'c', 'a', 't'>
[1] <'d', 'o', 'g'>
>>> enum(A * emptyset)
(empty)

# Concatenation of sets

>>> A = set(seq('p'), seq('t'))
>>> B = set(seq('a'), seq('i'))
>>> A * B
/(p + t)⋅(a + i)/
>>> enum(A * B)
[0] <'p', 'a'>
[1] <'p', 'i'>
[2] <'t', 'a'>
[3] <'t', 'i'>
>>> A = set(letters('cat'), letters('dog'))
>>> B = set(letters('s'), epsilon)
>>> enum(A * B)
[0] <'c', 'a', 't'>
[1] <'d', 'o', 'g'>
[2] <'c', 'a', 't', 's'>
[3] <'d', 'o', 'g', 's'>
>>> enum(A * set(epsilon))
[0] <'c', 'a', 't'>
[1] <'d', 'o', 'g'>
>>> enum(A * emptyset)
(empty)
>>> enum(alphabet('bdg') * letters('at'))
[0] <'b', 'a', 't'>
[1] <'d', 'a', 't'>
[2] <'g', 'a', 't'>
>>> enum(alphabet('bdg') * 'a')
[0] <'b', 'a'>
[1] <'d', 'a'>
[2] <'g', 'a'>
>>> enum(alphabet('bdg') * alphabet('ai'))
[0] <'b', 'a'>
[1] <'b', 'i'>
[2] <'d', 'a'>
[3] <'d', 'i'>
[4] <'g', 'a'>
[5] <'g', 'i'>

# Union of sequences

>>> letters('cat') + 'b'
/(c⋅a⋅t) + b/
>>> (letters('cat') + 'b') * 'c'
/((c⋅a⋅t) + b)⋅c/


# Kleene star
>>> star(lg('a'))
/a*/
>>> enum(star(lg('a')), 3)
[0] ε
[1] <'a'>
[2] <'a', 'a'>
...

# FSAs
>>> E(1, 'a', 2)
>>> E(2, 'b', 2)
>>> F(2)
>>> fsa = make_fsa()
>>> show(fsa)
Initial: 1
Final: 2
Edges:
  1 'a' 2
  2 'b' 2
>>> enum(fsa, 3)
[0] <'a'>
[1] <'a', 'b'>
[2] <'a', 'b', 'b'>
...
>>> seq('a', 'b', 'b') in fsa
True
>>> epsilon in fsa
False
